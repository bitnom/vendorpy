{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"vendorpy","text":"<p>Cloudflare Python workers vendoring CLI tool.</p>"},{"location":"modules/","title":"API Reference","text":"<p>Vendorpy CLI - A tool for automating Cloudflare Python Workers vendoring.</p> <p>This CLI tool automates the process of vendoring Python packages for Cloudflare Workers. It generates the requirements.txt file with the appropriate pruned packages and handles the vendoring process.</p> <p>Utility functions for the vendorpy CLI.</p>"},{"location":"modules/#vendorpy.cli.auto_vendor","title":"<code>auto_vendor(requirements_file=typer.Option('requirements.txt', '--requirements-file', '-r', help='Path to the requirements.txt file to generate'), vendor_file=typer.Option('vendor.txt', '--vendor-file', '-v', help='Path to the vendor.txt file to generate'), vendor_dir=typer.Option('src/vendor', '--vendor-dir', '-d', help='Directory to install vendored packages to'), python_version=typer.Option('3.12', '--python-version', '-p', help='Python version to use for vendoring (must be 3.12 for Cloudflare Workers)'))</code>","text":"<p>Automatically detect and vendor packages for Cloudflare Workers.</p> <p>This command automatically detects which packages need to be vendored by analyzing your project dependencies and comparing them with Cloudflare's built-in packages. It then handles the entire vendoring process in a single step.</p> Source code in <code>src/vendorpy/cli.py</code> <pre><code>@app.command()\ndef auto_vendor(\n    requirements_file: Path = typer.Option(  # noqa: B008\n        \"requirements.txt\",\n        \"--requirements-file\",\n        \"-r\",\n        help=\"Path to the requirements.txt file to generate\",\n    ),\n    vendor_file: Path = typer.Option(  # noqa: B008\n        \"vendor.txt\",\n        \"--vendor-file\",\n        \"-v\",\n        help=\"Path to the vendor.txt file to generate\",\n    ),\n    vendor_dir: Path = typer.Option(  # noqa: B008\n        \"src/vendor\",\n        \"--vendor-dir\",\n        \"-d\",\n        help=\"Directory to install vendored packages to\",\n    ),\n    python_version: str = typer.Option(  # noqa: B008\n        \"3.12\",\n        \"--python-version\",\n        \"-p\",\n        help=\"Python version to use for vendoring (must be 3.12 for Cloudflare Workers)\",\n    ),\n) -&gt; None:\n    \"\"\"\n    Automatically detect and vendor packages for Cloudflare Workers.\n\n    This command automatically detects which packages need to be vendored by analyzing your\n    project dependencies and comparing them with Cloudflare's built-in packages. It then\n    handles the entire vendoring process in a single step.\n    \"\"\"\n    try:\n        console.print(\n            Panel.fit(\n                \"Detecting packages that need to be vendored\",\n                title=\"[bold green]Step 1: Package Detection[/bold green]\",\n            )\n        )\n\n        # Detect packages to vendor\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            console=console,\n        ) as progress:\n            task = progress.add_task(\"Analyzing project dependencies...\", total=1)\n\n            try:\n                package_results = detect_packages_to_vendor()\n                vendor_packages = package_results[\"vendor\"]\n                built_in_packages = package_results[\"built_in\"]\n                progress.update(task, completed=1)\n            except Exception as e:\n                progress.update(\n                    task,\n                    completed=1,\n                    description=f\"Failed to analyze dependencies: {e}\",\n                )\n                raise\n\n        # Display results in a table\n        table = Table(title=\"Package Analysis Results\")\n        table.add_column(\"Package Type\", style=\"cyan\")\n        table.add_column(\"Count\", style=\"green\")\n        table.add_column(\"Packages\", style=\"yellow\")\n\n        table.add_row(\n            \"Need Vendoring\",\n            str(len(vendor_packages)),\n            \", \".join(vendor_packages) if vendor_packages else \"None\",\n        )\n        table.add_row(\n            \"Built-in (No Vendoring Required)\",\n            str(len(built_in_packages)),\n            \", \".join(built_in_packages) if built_in_packages else \"None\",\n        )\n\n        console.print(table)\n\n        # If there are no packages to vendor, notify and exit\n        if not vendor_packages:\n            console.print(\n                Panel.fit(\n                    \"No packages need to be vendored! All your dependencies are already built into Cloudflare Workers.\",\n                    title=\"[bold green]No Action Required[/bold green]\",\n                )\n            )\n            return\n\n        # Create vendor.txt file\n        console.print(\n            Panel.fit(\n                f\"Creating {vendor_file} with {len(vendor_packages)} packages that need vendoring\",\n                title=\"[bold green]Step 2: Vendor File Creation[/bold green]\",\n            )\n        )\n        create_vendor_file(vendor_packages, vendor_file)\n        console.print(f\"\u2705 Created {vendor_file}\")\n\n        # Generate requirements.txt with pruned packages\n        console.print(\n            Panel.fit(\n                \"Generating requirements.txt with pruned built-in packages\",\n                title=\"[bold green]Step 3: Requirements Generation[/bold green]\",\n            )\n        )\n        generate_requirements(requirements_file)\n\n        # Create virtual environments and vendor packages\n        console.print(\n            Panel.fit(\n                \"Setting up Python environment for vendoring\",\n                title=\"[bold green]Step 4: Environment Setup[/bold green]\",\n            )\n        )\n\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            console=console,\n        ) as progress:\n            # Create Python virtual environment\n            task1 = progress.add_task(\"Creating Python virtual environment...\", total=1)\n            venv_path = create_virtual_env(python_version)\n            progress.update(task1, completed=1)\n\n            # Create Pyodide virtual environment\n            task2 = progress.add_task(\n                \"Creating Pyodide virtual environment...\", total=1\n            )\n            pyodide_venv_path = create_pyodide_env(venv_path)\n            progress.update(task2, completed=1)\n\n            # Install packages to vendor directory\n            task3 = progress.add_task(\n                \"Installing packages to vendor directory...\", total=1\n            )\n            install_packages_to_vendor(pyodide_venv_path, vendor_file, vendor_dir)\n            progress.update(task3, completed=1)\n\n        console.print(\n            Panel.fit(\n                f\"\u2705 Successfully vendored {len(vendor_packages)} packages to {vendor_dir}\",\n                title=\"[bold green]Vendoring Complete[/bold green]\",\n            )\n        )\n\n        # Configure wrangler.toml or wrangler.jsonc\n        console.print(\n            Panel.fit(\n                \"Configuring wrangler for vendoring\",\n                title=\"[bold green]Step 5: Wrangler Configuration[/bold green]\",\n            )\n        )\n\n        config_result = configure_wrangler_for_vendor()\n\n        if config_result is None:\n            console.print(\n                Panel.fit(\n                    \"No wrangler.toml or wrangler.jsonc found in the current directory.\\n\\n\"\n                    \"Please manually configure your wrangler file to include the vendor directory:\\n\"\n                    \"\"\"\n[[rules]]\nglobs = [\"vendor/**\"]\ntype = \"Data\"\nfallthrough = true\n                    \"\"\",\n                    title=\"[bold yellow]Manual Configuration Required[/bold yellow]\",\n                )\n            )\n        else:\n            success, message = config_result\n            if success:\n                console.print(f\"\u2705 {message}\")\n            else:\n                console.print(\n                    Panel.fit(\n                        f\"{message}\\n\\n\"\n                        \"Please manually add the following to your wrangler configuration:\\n\"\n                        \"\"\"\n[[rules]]\nglobs = [\"vendor/**\"]\ntype = \"Data\"\nfallthrough = true\n                        \"\"\",\n                        title=\"[bold yellow]Manual Configuration Required[/bold yellow]\",\n                    )\n                )\n\n        console.print(\"\\n[bold]Next steps:[/bold]\")\n        console.print(\"1. Import your vendored packages in your code\")\n        console.print(\"2. Run 'wrangler dev' to test your worker\")\n\n    except Exception as e:\n        console.print(f\"[bold red]Error:[/bold red] {e!s}\")\n        sys.exit(1)\n</code></pre>"},{"location":"modules/#vendorpy.cli.generate_requirements","title":"<code>generate_requirements(requirements_file)</code>","text":"<p>Generate requirements.txt with pruned built-in packages.</p> Source code in <code>src/vendorpy/cli.py</code> <pre><code>def generate_requirements(requirements_file: Path) -&gt; None:\n    \"\"\"Generate requirements.txt with pruned built-in packages.\"\"\"\n\n    # Build the uv export command with all the prune flags\n    cmd = [\n        \"uv\",\n        \"export\",\n        \"--format\",\n        \"requirements-txt\",\n        \"-o\",\n        str(requirements_file),\n        \"--locked\",\n        \"--frozen\",\n        \"--no-dev\",\n        \"--prune\",\n    ]\n\n    # Add all built-in packages as prune flags\n    for package in CLOUDFLARE_BUILT_IN_PACKAGES:\n        cmd.extend([\"--prune\", package])\n\n    try:\n        # Using subprocess with a fixed command list is safe as we're not using shell=True\n        # and not accepting user input for the command itself\n        subprocess.run(cmd, check=True, capture_output=True, text=True)  # nosec B603\n        console.print(f\"\u2705 Generated {requirements_file} with pruned built-in packages\")\n    except subprocess.CalledProcessError as e:\n        console.print(f\"[bold red]Error generating requirements.txt:[/bold red] {e}\")\n        raise\n</code></pre>"},{"location":"modules/#vendorpy.cli.isbuiltin","title":"<code>isbuiltin(package_name=typer.Argument(..., help='Name of the package to check'), add_to_vendor=typer.Option(False, '--add', '-a', help=\"Add the package to vendor.txt if it's not built-in\"), vendor_file=typer.Option('vendor.txt', '--vendor-file', '-v', help='Path to the vendor.txt file'))</code>","text":"<p>Check if a package is built-in or needs to be vendored.</p> <p>If the package is not built-in, it can be automatically added to vendor.txt with the --add flag.</p> Source code in <code>src/vendorpy/cli.py</code> <pre><code>@app.command()\ndef isbuiltin(\n    package_name: str = typer.Argument(..., help=\"Name of the package to check\"),  # noqa: B008\n    add_to_vendor: bool = typer.Option(  # noqa: B008\n        False,\n        \"--add\",\n        \"-a\",\n        help=\"Add the package to vendor.txt if it's not built-in\",\n    ),\n    vendor_file: Path = typer.Option(  # noqa: B008\n        \"vendor.txt\",\n        \"--vendor-file\",\n        \"-v\",\n        help=\"Path to the vendor.txt file\",\n    ),\n) -&gt; None:\n    \"\"\"Check if a package is built-in or needs to be vendored.\n\n    If the package is not built-in, it can be automatically added to vendor.txt with the --add flag.\n    \"\"\"\n    try:\n        # Validate package name\n        if not package_name or not package_name.strip():\n            console.print(\"[bold red]Error:[/bold red] Package name cannot be empty.\")\n            sys.exit(1)\n\n        # Normalize package name (convert to lowercase and replace dashes with underscores)\n        normalized_name = package_name.lower().replace(\"-\", \"_\")\n\n        # Check if the package is in the built-in packages list\n        is_built_in = any(\n            pkg.lower().replace(\"-\", \"_\") == normalized_name\n            for pkg in CLOUDFLARE_BUILT_IN_PACKAGES\n        )\n\n        if is_built_in:\n            try:\n                # Find the exact package name with correct casing\n                exact_name = next(\n                    pkg\n                    for pkg in CLOUDFLARE_BUILT_IN_PACKAGES\n                    if pkg.lower().replace(\"-\", \"_\") == normalized_name\n                )\n                console.print(\n                    Panel.fit(\n                        f\"[bold green]\u2713 {exact_name}[/bold green] is a built-in package in Cloudflare Workers.\\n\\n\"\n                        \"You can use it directly without vendoring.\\n\\n\"\n                        \"Add it to your requirements.txt file:\"\n                        f\"\\n  {exact_name}\",\n                        title=\"[bold green]Built-in Package[/bold green]\",\n                    )\n                )\n            except StopIteration:\n                # This should not happen, but handle it just in case\n                console.print(\n                    Panel.fit(\n                        f\"[bold green]\u2713 {package_name}[/bold green] is a built-in package in Cloudflare Workers.\\n\\n\"\n                        \"You can use it directly without vendoring.\\n\\n\"\n                        \"Add it to your requirements.txt file:\"\n                        f\"\\n  {package_name}\",\n                        title=\"[bold green]Built-in Package[/bold green]\",\n                    )\n                )\n        else:\n            console.print(\n                Panel.fit(\n                    f\"[bold yellow]! {package_name}[/bold yellow] is NOT a built-in package in Cloudflare Workers.\\n\\n\"\n                    \"You need to vendor this package.\",\n                    title=\"[bold yellow]Package Needs Vendoring[/bold yellow]\",\n                )\n            )\n\n            # Check if we should add the package to vendor.txt\n            if add_to_vendor:\n                try:\n                    # Create vendor.txt if it doesn't exist\n                    if not vendor_file.exists():\n                        vendor_file.parent.mkdir(parents=True, exist_ok=True)\n                        vendor_file.touch()\n                        console.print(f\"Created {vendor_file} file.\")\n\n                    # Check if the package is already in vendor.txt\n                    with open(vendor_file, \"r\") as f:\n                        vendor_packages = [\n                            line.strip()\n                            for line in f\n                            if line.strip() and not line.strip().startswith(\"#\")\n                        ]\n\n                    if package_name in vendor_packages:\n                        console.print(\n                            f\"Package {package_name} is already in {vendor_file}.\"\n                        )\n                    else:\n                        # Add the package to vendor.txt\n                        with open(vendor_file, \"a\") as f:\n                            # Add a newline if the file doesn't end with one\n                            if vendor_file.exists() and vendor_file.stat().st_size &gt; 0:\n                                with open(vendor_file, \"r\") as check_f:\n                                    content = check_f.read()\n                                    if content and not content.endswith(\"\\n\"):\n                                        f.write(\"\\n\")\n\n                            f.write(f\"{package_name}\\n\")\n                        console.print(\n                            f\"[bold green]\u2713 Added {package_name} to {vendor_file}[/bold green]\"\n                        )\n                except Exception as e:\n                    console.print(\n                        f\"[bold red]Error adding package to vendor.txt:[/bold red] {e!s}\"\n                    )\n            else:\n                console.print(\"\\nTo add this package to your vendor.txt file:\")\n                console.print(\n                    f\"  [bold]vendorpy isbuiltin {package_name} --add[/bold]\",\n                    style=\"blue\",\n                )\n                console.print(\"\\nOr manually add it to your vendor.txt file and run:\")\n                console.print(\"  [bold]vendorpy vendor[/bold]\", style=\"blue\")\n    except Exception as e:\n        console.print(f\"[bold red]Error checking package:[/bold red] {e!s}\")\n        sys.exit(1)\n</code></pre>"},{"location":"modules/#vendorpy.cli.list_built_in","title":"<code>list_built_in()</code>","text":"<p>List all built-in packages available in Cloudflare Workers.</p> Source code in <code>src/vendorpy/cli.py</code> <pre><code>@app.command()\ndef list_built_in() -&gt; None:\n    \"\"\"List all built-in packages available in Cloudflare Workers.\"\"\"\n    console.print(\n        Panel.fit(\n            \"\\n\".join(f\"- {pkg}\" for pkg in sorted(CLOUDFLARE_BUILT_IN_PACKAGES)),\n            title=\"[bold green]Cloudflare Workers Built-in Packages[/bold green]\",\n        )\n    )\n</code></pre>"},{"location":"modules/#vendorpy.cli.main","title":"<code>main()</code>","text":"<p>Main entry point for the CLI.</p> Source code in <code>src/vendorpy/cli.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"Main entry point for the CLI.\"\"\"\n    app()\n</code></pre>"},{"location":"modules/#vendorpy.cli.vendor","title":"<code>vendor(vendor_file=typer.Option('vendor.txt', '--vendor-file', '-v', help='Path to the vendor.txt file containing packages to vendor', exists=True), requirements_file=typer.Option('requirements.txt', '--requirements-file', '-r', help='Path to the requirements.txt file to generate'), vendor_dir=typer.Option('src/vendor', '--vendor-dir', '-d', help='Directory to install vendored packages to'), python_version=typer.Option('3.12', '--python-version', '-p', help='Python version to use for vendoring (must be 3.12 for Cloudflare Workers)'), skip_built_in=typer.Option(True, '--skip-built-in/--include-built-in', help='Skip built-in Cloudflare packages in requirements.txt'))</code>","text":"<p>Vendor Python packages for Cloudflare Workers.</p> <p>This command automates the process of vendoring Python packages for Cloudflare Workers. It generates the requirements.txt file with the appropriate pruned packages and handles the vendoring process.</p> Source code in <code>src/vendorpy/cli.py</code> <pre><code>@app.command()\ndef vendor(\n    vendor_file: Path = typer.Option(  # noqa: B008\n        \"vendor.txt\",\n        \"--vendor-file\",\n        \"-v\",\n        help=\"Path to the vendor.txt file containing packages to vendor\",\n        exists=True,\n    ),\n    requirements_file: Path = typer.Option(  # noqa: B008\n        \"requirements.txt\",\n        \"--requirements-file\",\n        \"-r\",\n        help=\"Path to the requirements.txt file to generate\",\n    ),\n    vendor_dir: Path = typer.Option(  # noqa: B008\n        \"src/vendor\",\n        \"--vendor-dir\",\n        \"-d\",\n        help=\"Directory to install vendored packages to\",\n    ),\n    python_version: str = typer.Option(  # noqa: B008\n        \"3.12\",\n        \"--python-version\",\n        \"-p\",\n        help=\"Python version to use for vendoring (must be 3.12 for Cloudflare Workers)\",\n    ),\n    skip_built_in: bool = typer.Option(  # noqa: B008\n        True,\n        \"--skip-built-in/--include-built-in\",\n        help=\"Skip built-in Cloudflare packages in requirements.txt\",\n    ),\n) -&gt; None:\n    \"\"\"\n    Vendor Python packages for Cloudflare Workers.\n\n    This command automates the process of vendoring Python packages for Cloudflare Workers.\n    It generates the requirements.txt file with the appropriate pruned packages and\n    handles the vendoring process.\n    \"\"\"\n    try:\n        # Create vendor directory if it doesn't exist\n        vendor_dir.mkdir(parents=True, exist_ok=True)\n\n        # Generate requirements.txt with pruned packages\n        if skip_built_in:\n            console.print(\n                Panel.fit(\n                    \"Generating requirements.txt with pruned built-in packages\",\n                    title=\"[bold green]Step 1: Requirements Generation[/bold green]\",\n                )\n            )\n            generate_requirements(requirements_file)\n\n        # Create virtual environments and vendor packages\n        console.print(\n            Panel.fit(\n                \"Setting up Python environment for vendoring\",\n                title=\"[bold green]Step 2: Environment Setup[/bold green]\",\n            )\n        )\n\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            console=console,\n        ) as progress:\n            # Create Python virtual environment\n            task1 = progress.add_task(\"Creating Python virtual environment...\", total=1)\n            venv_path = create_virtual_env(python_version)\n            progress.update(task1, completed=1)\n\n            # Create Pyodide virtual environment\n            task2 = progress.add_task(\n                \"Creating Pyodide virtual environment...\", total=1\n            )\n            pyodide_venv_path = create_pyodide_env(venv_path)\n            progress.update(task2, completed=1)\n\n            # Install packages to vendor directory\n            task3 = progress.add_task(\n                \"Installing packages to vendor directory...\", total=1\n            )\n            install_packages_to_vendor(pyodide_venv_path, vendor_file, vendor_dir)\n            progress.update(task3, completed=1)\n\n        console.print(\n            Panel.fit(\n                f\"\u2705 Successfully vendored packages from {vendor_file} to {vendor_dir}\",\n                title=\"[bold green]Vendoring Complete[/bold green]\",\n            )\n        )\n\n        console.print(\"\\n[bold]Next steps:[/bold]\")\n        console.print(\"1. Make sure your wrangler.toml includes the vendor directory:\")\n        console.print(\n            \"\"\"\n[[rules]]\nglobs = [\"vendor/**\"]\ntype = \"Data\"\nfallthrough = true\n        \"\"\",\n            style=\"green\",\n        )\n        console.print(\"2. Import your vendored packages in your code\")\n        console.print(\"3. Run 'wrangler dev' to test your worker\")\n\n    except Exception as e:\n        console.print(f\"[bold red]Error:[/bold red] {e!s}\")\n        sys.exit(1)\n</code></pre>"},{"location":"modules/#vendorpy.utils.add_vendor_rule_to_config","title":"<code>add_vendor_rule_to_config(config_path, config_type)</code>","text":"<p>Add vendor rule to wrangler configuration if not already present.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Path</code> <p>Path to the configuration file</p> required <code>config_type</code> <code>str</code> <p>Type of configuration file ('toml' or 'jsonc')</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the rule was added or already present, False if there was an error</p> Source code in <code>src/vendorpy/utils.py</code> <pre><code>def add_vendor_rule_to_config(config_path: Path, config_type: str) -&gt; bool:\n    \"\"\"\n    Add vendor rule to wrangler configuration if not already present.\n\n    Args:\n        config_path: Path to the configuration file\n        config_type: Type of configuration file ('toml' or 'jsonc')\n\n    Returns:\n        True if the rule was added or already present, False if there was an error\n    \"\"\"\n    try:\n        if config_type == \"toml\":\n            # Read the TOML file\n            with open(config_path, \"rb\") as f:\n                config_data = tomli.load(f)\n\n            # Check if the rule is already present\n            if is_vendor_rule_present(config_data, config_type):\n                return True\n\n            # Add the rule\n            if \"rules\" not in config_data:\n                config_data[\"rules\"] = []\n\n            vendor_rule = {\"globs\": [\"vendor/**\"], \"type\": \"Data\", \"fallthrough\": True}\n            config_data[\"rules\"].append(vendor_rule)\n\n            # Write the updated TOML file\n            with open(config_path, \"wb\") as f:\n                tomli_w.dump(config_data, f)\n\n            return True\n\n        elif config_type == \"jsonc\":\n            # Read the JSONC file\n            with open(config_path, \"r\") as f:\n                content = f.read()\n\n            # Check if the rule is already present\n            if is_vendor_rule_present(content, config_type):\n                return True\n\n            # Simple JSON modification that preserves comments\n            # Find the position to insert the rule\n            import re\n\n            # If there's already a rules array, we'll add to it\n            rules_match = re.search(r'\"rules\"\\s*:\\s*\\[\\s*', content)\n            if rules_match:\n                # Find the end of the rules array\n                end_pos = rules_match.end()\n                # Insert the vendor rule at the beginning of the rules array\n                vendor_rule_str = \"\"\"\n  {\n    \"globs\": [\"vendor/**\"],\n    \"type\": \"Data\",\n    \"fallthrough\": true\n  },\"\"\"\n                # Insert the rule after the opening bracket of the rules array\n                new_content = content[:end_pos] + vendor_rule_str + content[end_pos:]\n            else:\n                # If there's no rules array, we'll need to add it\n                # Find the last closing brace\n                last_brace = content.rstrip().rfind(\"}\")\n                if last_brace == -1:\n                    # Invalid JSON\n                    return False\n\n                vendor_rule_str = \"\"\"\n  \"rules\": [\n    {\n      \"globs\": [\"vendor/**\"],\n      \"type\": \"Data\",\n      \"fallthrough\": true\n    }\n  ]\"\"\"\n                # If there are already properties, add a comma\n                if content[:last_brace].rstrip().endswith(\"}\") or content[\n                    :last_brace\n                ].rstrip().endswith(\"]\"):\n                    vendor_rule_str = \",\" + vendor_rule_str\n\n                # Insert the rules array before the final closing brace\n                new_content = (\n                    content[:last_brace] + vendor_rule_str + content[last_brace:]\n                )\n\n            # Write the updated JSONC file\n            with open(config_path, \"w\") as f:\n                f.write(new_content)\n\n            return True\n\n        return False\n\n    except Exception as e:\n        # Log the error but don't raise it - we don't want to stop the vendoring process\n        # if the wrangler config update fails\n        import logging\n\n        logging.error(f\"Error updating wrangler config: {e}\")\n        return False\n</code></pre>"},{"location":"modules/#vendorpy.utils.configure_wrangler_for_vendor","title":"<code>configure_wrangler_for_vendor()</code>","text":"<p>Configure wrangler.toml or wrangler.jsonc to include vendor directory.</p> <p>Returns:</p> Type Description <code>Optional[Tuple[bool, str]]</code> <p>Tuple containing success status and message, or None if no wrangler config was found</p> Source code in <code>src/vendorpy/utils.py</code> <pre><code>def configure_wrangler_for_vendor() -&gt; Optional[Tuple[bool, str]]:\n    \"\"\"\n    Configure wrangler.toml or wrangler.jsonc to include vendor directory.\n\n    Returns:\n        Tuple containing success status and message, or None if no wrangler config was found\n    \"\"\"\n    # Find the wrangler configuration file\n    config_result = find_wrangler_config()\n    if not config_result:\n        return None\n\n    config_path, config_type = config_result\n\n    # Add vendor rule to config\n    success = add_vendor_rule_to_config(config_path, config_type)\n\n    if success:\n        return True, f\"Successfully configured {config_path.name} for vendoring\"\n    else:\n        return False, f\"Failed to configure {config_path.name} for vendoring\"\n</code></pre>"},{"location":"modules/#vendorpy.utils.create_pyodide_env","title":"<code>create_pyodide_env(venv_path)</code>","text":"<p>Create a Pyodide virtual environment.</p> <p>Parameters:</p> Name Type Description Default <code>venv_path</code> <code>Path</code> <p>Path to the Python virtual environment</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the created Pyodide virtual environment</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the pyodide command is not found or fails to create the environment</p> Source code in <code>src/vendorpy/utils.py</code> <pre><code>def create_pyodide_env(venv_path: Path) -&gt; Path:\n    \"\"\"\n    Create a Pyodide virtual environment.\n\n    Args:\n        venv_path: Path to the Python virtual environment\n\n    Returns:\n        Path to the created Pyodide virtual environment\n\n    Raises:\n        RuntimeError: If the pyodide command is not found or fails to create the environment\n    \"\"\"\n    pyodide_venv_path = Path(\".venv-pyodide\")\n\n    # Create Pyodide virtual environment\n    pyodide_path = venv_path / \"bin\" / \"pyodide\"\n\n    # Check if pyodide exists\n    if not pyodide_path.exists():\n        raise RuntimeError(\n            f\"Pyodide command not found at {pyodide_path}. Make sure pyodide-build is installed correctly.\"\n        )\n\n    try:\n        subprocess.run(\n            [str(pyodide_path), \"venv\", str(pyodide_venv_path)],\n            check=True,\n            capture_output=True,\n            text=True,\n        )  # nosec B603\n    except subprocess.CalledProcessError as err:\n        error_output = err.stderr if err.stderr else \"Unknown error\"\n        raise RuntimeError(\n            f\"Failed to create Pyodide environment: {error_output}\"\n        ) from err\n\n    # Verify the environment was created\n    if not pyodide_venv_path.exists():\n        raise RuntimeError(\n            f\"Pyodide environment was not created at {pyodide_venv_path}\"\n        )\n\n    return pyodide_venv_path\n</code></pre>"},{"location":"modules/#vendorpy.utils.create_vendor_file","title":"<code>create_vendor_file(vendor_packages, vendor_file)</code>","text":"<p>Create or update the vendor.txt file with packages that need to be vendored.</p> <p>Parameters:</p> Name Type Description Default <code>vendor_packages</code> <code>List[str]</code> <p>List of package names to vendor</p> required <code>vendor_file</code> <code>Path</code> <p>Path to the vendor.txt file</p> required Source code in <code>src/vendorpy/utils.py</code> <pre><code>def create_vendor_file(vendor_packages: List[str], vendor_file: Path) -&gt; None:\n    \"\"\"\n    Create or update the vendor.txt file with packages that need to be vendored.\n\n    Args:\n        vendor_packages: List of package names to vendor\n        vendor_file: Path to the vendor.txt file\n    \"\"\"\n    # Create vendor file directory if it doesn't exist\n    vendor_file.parent.mkdir(parents=True, exist_ok=True)\n\n    # Write packages to vendor.txt\n    with open(vendor_file, \"w\") as f:\n        for package in vendor_packages:\n            f.write(f\"{package}\\n\")\n</code></pre>"},{"location":"modules/#vendorpy.utils.create_virtual_env","title":"<code>create_virtual_env(python_version='3.12')</code>","text":"<p>Create a Python virtual environment.</p> <p>Parameters:</p> Name Type Description Default <code>python_version</code> <code>str</code> <p>The Python version to use (must be 3.12 for Cloudflare Workers)</p> <code>'3.12'</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the created virtual environment</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If Python is not available or if the virtual environment creation fails</p> <code>FileNotFoundError</code> <p>If pip is not found in the created environment</p> Source code in <code>src/vendorpy/utils.py</code> <pre><code>def create_virtual_env(python_version: str = \"3.12\") -&gt; Path:\n    \"\"\"\n    Create a Python virtual environment.\n\n    Args:\n        python_version: The Python version to use (must be 3.12 for Cloudflare Workers)\n\n    Returns:\n        Path to the created virtual environment\n\n    Raises:\n        RuntimeError: If Python is not available or if the virtual environment creation fails\n        FileNotFoundError: If pip is not found in the created environment\n    \"\"\"\n    venv_path = Path(\".venv\")\n\n    # Remove existing virtual environment if it exists\n    if venv_path.exists():\n        import shutil\n\n        shutil.rmtree(venv_path)\n\n    # Check if Python version is available\n    try:\n        # Using capture_output instead of PIPE for stdout and stderr\n        subprocess.run(\n            [f\"python{python_version}\", \"--version\"],\n            check=True,\n            capture_output=True,\n            text=True,  # nosec B603\n        )\n    except (subprocess.CalledProcessError, FileNotFoundError) as err:\n        # Use raise from to properly chain exceptions\n        msg = f\"Python {python_version} is not available. Please install Python {python_version} and try again.\"\n        raise RuntimeError(msg) from err\n\n    # Create virtual environment\n    try:\n        # Using fixed command list is safe as we're not using shell=True\n        subprocess.run(\n            [f\"python{python_version}\", \"-m\", \"venv\", str(venv_path)],\n            check=True,\n            capture_output=True,\n            text=True,\n        )  # nosec B603\n    except subprocess.CalledProcessError as err:\n        error_output = err.stderr if err.stderr else \"Unknown error\"\n        raise RuntimeError(\n            f\"Failed to create virtual environment: {error_output}\"\n        ) from err\n\n    # Verify the environment was created\n    if not venv_path.exists():\n        raise RuntimeError(f\"Virtual environment was not created at {venv_path}\")\n\n    # Install pyodide-build in the virtual environment\n    pip_path = venv_path / \"bin\" / \"pip\"\n\n    # Check if pip exists\n    if not pip_path.exists():\n        raise FileNotFoundError(\n            f\"pip not found in virtual environment at {pip_path}. \"\n            \"Make sure the virtual environment was created correctly.\"\n        )\n\n    try:\n        subprocess.run(\n            [str(pip_path), \"install\", \"pyodide-build\"],\n            check=True,\n            capture_output=True,\n            text=True,\n        )  # nosec B603\n    except subprocess.CalledProcessError as err:\n        error_output = err.stderr if err.stderr else \"Unknown error\"\n        raise RuntimeError(f\"Failed to install pyodide-build: {error_output}\") from err\n\n    return venv_path\n</code></pre>"},{"location":"modules/#vendorpy.utils.detect_packages_to_vendor","title":"<code>detect_packages_to_vendor()</code>","text":"<p>Detect which packages need to be vendored by comparing project dependencies with built-in Cloudflare packages.</p> <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>Dictionary with 'vendor' and 'built_in' keys, containing lists of package names</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If dependency extraction fails</p> Source code in <code>src/vendorpy/utils.py</code> <pre><code>def detect_packages_to_vendor() -&gt; Dict[str, List[str]]:\n    \"\"\"\n    Detect which packages need to be vendored by comparing project dependencies\n    with built-in Cloudflare packages.\n\n    Returns:\n        Dictionary with 'vendor' and 'built_in' keys, containing lists of package names\n\n    Raises:\n        RuntimeError: If dependency extraction fails\n    \"\"\"\n    # Get all project dependencies\n    project_dependencies = extract_project_dependencies()\n\n    # Normalize built-in package names for comparison\n    normalized_built_in = {\n        pkg.lower().replace(\"-\", \"_\") for pkg in CLOUDFLARE_BUILT_IN_PACKAGES\n    }\n\n    # Determine which packages need to be vendored\n    to_vendor = project_dependencies - normalized_built_in\n    built_in = project_dependencies &amp; normalized_built_in\n\n    # Get original package names for the ones that need to be vendored\n    # This is needed because we normalized the names for comparison\n    vendor_packages = []\n    for package in to_vendor:\n        # Use the original name if available\n        # Note: This is a simple implementation that assumes the package name\n        # in the output of uv export is the same as what should be in vendor.txt\n        vendor_packages.append(package.replace(\"_\", \"-\"))\n\n    # Get original package names for built-in packages\n    built_in_packages = []\n    for built_in_pkg in built_in:\n        # Find the exact package name with correct casing\n        exact_name = next(\n            (\n                pkg\n                for pkg in CLOUDFLARE_BUILT_IN_PACKAGES\n                if pkg.lower().replace(\"-\", \"_\") == built_in_pkg\n            ),\n            built_in_pkg,  # Use normalized name if exact match not found\n        )\n        built_in_packages.append(exact_name)\n\n    return {\n        \"vendor\": sorted(vendor_packages),\n        \"built_in\": sorted(built_in_packages),\n    }\n</code></pre>"},{"location":"modules/#vendorpy.utils.extract_project_dependencies","title":"<code>extract_project_dependencies()</code>","text":"<p>Extract all project dependencies using uv export.</p> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set of package names that the project depends on</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If uv is not available or if the command fails</p> Source code in <code>src/vendorpy/utils.py</code> <pre><code>def extract_project_dependencies() -&gt; Set[str]:\n    \"\"\"\n    Extract all project dependencies using uv export.\n\n    Returns:\n        Set of package names that the project depends on\n\n    Raises:\n        RuntimeError: If uv is not available or if the command fails\n    \"\"\"\n    try:\n        # Run uv export to get all dependencies from the lockfile\n        result = subprocess.run(\n            [\"uv\", \"export\", \"--format\", \"json\"],\n            check=True,\n            capture_output=True,\n            text=True,\n        )  # nosec B603\n\n        # Parse the JSON output\n        packages_data = json.loads(result.stdout)\n\n        # Extract package names (without versions)\n        package_names = set()\n\n        # Process the dependencies structure from uv export\n        if \"dependencies\" in packages_data:\n            for package_name, package_info in packages_data[\"dependencies\"].items():\n                # Normalize package name (lowercase, replace hyphens with underscores)\n                normalized_name = package_name.lower().replace(\"-\", \"_\")\n                package_names.add(normalized_name)\n\n        return package_names\n    except (subprocess.CalledProcessError, json.JSONDecodeError, KeyError) as err:\n        error_output = getattr(err, \"stderr\", \"Unknown error\")\n        raise RuntimeError(\n            f\"Failed to extract project dependencies: {error_output}\"\n        ) from err\n    except FileNotFoundError as err:\n        raise RuntimeError(\n            \"uv command not found. Please install uv using 'pip install uv'\"\n        ) from err\n</code></pre>"},{"location":"modules/#vendorpy.utils.find_wrangler_config","title":"<code>find_wrangler_config()</code>","text":"<p>Find the wrangler configuration file in the current directory.</p> <p>Returns:</p> Type Description <code>Optional[Tuple[Path, str]]</code> <p>Optional tuple containing the path to the wrangler config file and its type ('toml' or 'jsonc')</p> <code>Optional[Tuple[Path, str]]</code> <p>or None if no wrangler configuration file is found</p> Source code in <code>src/vendorpy/utils.py</code> <pre><code>def find_wrangler_config() -&gt; Optional[Tuple[Path, str]]:\n    \"\"\"\n    Find the wrangler configuration file in the current directory.\n\n    Returns:\n        Optional tuple containing the path to the wrangler config file and its type ('toml' or 'jsonc')\n        or None if no wrangler configuration file is found\n    \"\"\"\n    # Check for wrangler.toml first (more common)\n    wrangler_toml = Path(\"wrangler.toml\")\n    if wrangler_toml.exists():\n        return wrangler_toml, \"toml\"\n\n    # Check for wrangler.jsonc as an alternative\n    wrangler_jsonc = Path(\"wrangler.jsonc\")\n    if wrangler_jsonc.exists():\n        return wrangler_jsonc, \"jsonc\"\n\n    # No wrangler config found\n    return None\n</code></pre>"},{"location":"modules/#vendorpy.utils.install_packages_to_vendor","title":"<code>install_packages_to_vendor(pyodide_venv_path, vendor_file, vendor_dir)</code>","text":"<p>Install packages to the vendor directory.</p> <p>Parameters:</p> Name Type Description Default <code>pyodide_venv_path</code> <code>Path</code> <p>Path to the Pyodide virtual environment</p> required <code>vendor_file</code> <code>Path</code> <p>Path to the vendor.txt file</p> required <code>vendor_dir</code> <code>Path</code> <p>Directory to install vendored packages to</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the vendor.txt file or pip command is not found</p> <code>RuntimeError</code> <p>If the installation fails</p> Source code in <code>src/vendorpy/utils.py</code> <pre><code>def install_packages_to_vendor(\n    pyodide_venv_path: Path, vendor_file: Path, vendor_dir: Path\n) -&gt; None:\n    \"\"\"\n    Install packages to the vendor directory.\n\n    Args:\n        pyodide_venv_path: Path to the Pyodide virtual environment\n        vendor_file: Path to the vendor.txt file\n        vendor_dir: Directory to install vendored packages to\n\n    Raises:\n        FileNotFoundError: If the vendor.txt file or pip command is not found\n        RuntimeError: If the installation fails\n    \"\"\"\n    # Check if vendor file exists and is not empty\n    if not vendor_file.exists():\n        raise FileNotFoundError(f\"Vendor file not found: {vendor_file}\")\n\n    # Check if vendor file is empty\n    if vendor_file.stat().st_size == 0:\n        raise ValueError(f\"Vendor file is empty: {vendor_file}\")\n\n    # Create vendor directory if it doesn't exist\n    vendor_dir.mkdir(parents=True, exist_ok=True)\n\n    # Check if pip exists in the Pyodide environment\n    pip_path = pyodide_venv_path / \"bin\" / \"pip\"\n    if not pip_path.exists():\n        raise FileNotFoundError(\n            f\"pip not found in Pyodide environment at {pip_path}. \"\n            \"Make sure the Pyodide environment was created correctly.\"\n        )\n\n    try:\n        # Install packages to vendor directory\n        result = subprocess.run(\n            [str(pip_path), \"install\", \"-t\", str(vendor_dir), \"-r\", str(vendor_file)],\n            check=True,\n            capture_output=True,\n            text=True,\n        )  # nosec B603\n\n        # Check if any packages were installed\n        if \"Successfully installed\" not in result.stdout and not any(\n            Path(vendor_dir).glob(\"*/__init__.py\")\n        ):\n            raise RuntimeError(\n                f\"No packages were installed to {vendor_dir}. \"\n                \"Check your vendor.txt file and make sure the packages are available.\"\n            )\n    except subprocess.CalledProcessError as err:\n        error_output = err.stderr if err.stderr else \"Unknown error\"\n        raise RuntimeError(f\"Failed to install packages: {error_output}\") from err\n</code></pre>"},{"location":"modules/#vendorpy.utils.is_vendor_rule_present","title":"<code>is_vendor_rule_present(config_data, config_type)</code>","text":"<p>Check if the vendor rule is already present in the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config_data</code> <code>Union[Dict[str, Any], str]</code> <p>The parsed configuration data or content string</p> required <code>config_type</code> <code>str</code> <p>Type of configuration file ('toml' or 'jsonc')</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the vendor rule is present, False otherwise</p> Source code in <code>src/vendorpy/utils.py</code> <pre><code>def is_vendor_rule_present(\n    config_data: Union[Dict[str, Any], str], config_type: str\n) -&gt; bool:\n    \"\"\"\n    Check if the vendor rule is already present in the configuration.\n\n    Args:\n        config_data: The parsed configuration data or content string\n        config_type: Type of configuration file ('toml' or 'jsonc')\n\n    Returns:\n        True if the vendor rule is present, False otherwise\n    \"\"\"\n    if config_type == \"toml\":\n        if not isinstance(config_data, dict):\n            return False\n\n        # Check if rules exist and contain vendor configuration\n        if \"rules\" not in config_data:\n            return False\n\n        rules = config_data.get(\"rules\", [])\n        for rule in rules:\n            if (\n                isinstance(rule, dict)\n                and rule.get(\"globs\") == [\"vendor/**\"]\n                and rule.get(\"type\") == \"Data\"\n                and rule.get(\"fallthrough\") is True\n            ):\n                return True\n\n        return False\n\n    elif config_type == \"jsonc\":\n        # For JSONC, we'll check the string content since parsing JSONC is more complex\n        vendor_pattern = '\"globs\":\\\\s*\\\\[\\\\s*\"vendor/\\\\*\\\\*\"\\\\s*\\\\]'\n        data_pattern = '\"type\":\\\\s*\"Data\"'\n        fallthrough_pattern = '\"fallthrough\":\\\\s*true'\n\n        import re\n\n        if (\n            isinstance(config_data, str)\n            and re.search(vendor_pattern, config_data)\n            and re.search(data_pattern, config_data)\n            and re.search(fallthrough_pattern, config_data)\n        ):\n            return True\n\n        return False\n\n    return False\n</code></pre>"}]}